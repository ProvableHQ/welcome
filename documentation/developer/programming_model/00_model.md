---
id: model
title: The Leo Programming Model
sidebar_label: Model
---

This section assumes that you have knowledge of [records](../../aleo/concepts/01_records.md) and their use in the [Aleo Protocol](../../aleo/concepts/00_accounts.md).

## Leo Record Runtime

Each Leo `.leo` file is compiled into [predicate](../../aleo/concepts/07_glossary.md#predicate).
Each predicate lives in a [record](../../aleo/concepts/01_records.md). Each record lives in a [transaction](../../aleo/concepts/02_transactions.md).
An Aleo transaction spends two old records: `old_record_0`, `old_record_1` and creates two new records: `new_record_0`, `new_record_1`.

## Registers

A register stores intermediate record state during runtime.
During runtime, we load an initial input state into a record and expect and output state after the record is run.

* Input state is stored in the input register.
* Output state is stored in the output register.

```leo
input_register -> record -> output_register
```

Leo executes each record in order:

1. `state_0 -> old_record_0 -> state_1`
2. `state_1 -> old_record_1 -> state_2`
3. `state_2 -> new_record_0 -> state_3`
4. `state_3 -> new_record_1 -> state_4`

To ensure the accuracy of input and output register state, a hash of each is stored in the local data commitment for each record. 

## Committing to Register Data.

Register values are hashed and included in the [local data commitment](../../aleo/concepts/02_transactions.md#local-data-commitment).
The Leo runtime calculates the [record commitment](../../aleo/concepts/07_glossary.md#record-commitment) as well as 
the local data commitment to ensure that all record data is included in the [local data root](../../aleo/concepts/02_transactions.md#ledger-digest).

### `.in` and `.out` files

#### Input Registers

Input register information is passed to Leo as program input inside the `.in` file indicated by the `[registers]` section.

```leo title="project.in"
[main]
data: u8[32] = [0u8; 32];

[registers]
token_id: u8[32] = [0u8; 32];
value_balance: u64 = 0;
```

#### Accessing Input Registers

Input register values can be accessed by passing a `register` variable into the `main` function of a Leo file.

```leo
function main(register, data: u8[32]) {
    let a = register.value_balance + 5;

    assert_eq!(register.token_id, data);
}
``` 

#### Output Registers

Output register information is stored inside the `.out` file indicated by the `[registers]` section.

```leo title="project.out"
[registers]
token_id: u8[32] = [0u8; 32];
value_balance: u64 = 0;
```

#### Writing to Output Registers

The return function of main will automatically write to the output registers in `.out`.

:::info
To see how to load register files into tests, checkout [**Writing Tests**](../language/10_tests.md#integration-tests).
:::

## State

Leo files can access record and leaf state passed into the state file. 
For example, it could be necessary for Leo programs to access the address, value, or other private fields within a record. 
This context is included in the state file.

### `.state` file

State information generated by the current Leo runtime.

```leo title="project.state"
[[public]]

[state]
leaf_index: u32 = 0;
root: u8[32] = [0u8; 32];

[[private]]

[record]
serial_number: u8[32] = [0u8; 32];
commitment: u8[32] = [0u8; 32];
owner: address = aleo1...;
value: u64 = 5;
payload: u8[32] = [0u8; 32];
birth_program_id: u8[32] = [0u8; 32];
death_program_id: u8[32] = [0u8; 32];
serial_number_nonce: u8[32] = [0u8; 32];
commitment_randomness: u8[32] = [0u8; 32];

[state_leaf]
path: u8[32][2] = [ [0u8; 32], [0u8; 32] ];
memo: u8[32] = [0u8; 32];
network_id: u8 = 0;
leaf_randomness: u8[32] = [0u8; 32];
```

:::info
To see how to load state files into tests, checkout [**Writing Tests**](../language/10_tests.md#integration-tests)
:::

## Where Register and State Files are Stored

The Leo [CLI](../cli/00_new.md) creates an `inputs/` and an `outputs/` folder to store program input and output information from the compiler.
These folders also provide access to register, record, and leaf state information.
We already introduced the program [inputs](../language/07_inputs.md) `.in` file located in the `inputs/` folder.
When each Leo file in a transaction is run, `.out` files as well as a `.state` file are created as follows:

```bash
project/
├── Leo.toml
│
├── inputs/
│ ├── project.in
│ └── project.state
│
├── outputs/
│ └── project.out
│ 
└── src/    
  └── main.leo
```

To see how these files are useful lets walk through a familiar example of transferring an [ERC20 token](./01_erc20.md) on Aleo.